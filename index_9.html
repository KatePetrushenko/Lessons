<html>

<head>
    <title>JAVASCRIPT HW3</title>
</head>

<body>
    <script>
        // ЗАДАНИЯ ДЛЯ РАЗМИНКИ!!!!!!)))

        //1) Есть участок кода! обернуть в try catch нужный участок кода и выбросить ошибку если getResult возвращает undefined
        function getResult() {
            var obj = {
                name: 'Sergei',
                lastName: 'Shakhov'
            }
            return 
            obj;
        }
        const a = getResult();
		console.log('RESULT', a);
        try {
            if (!a) throw new Error('Error!!!');
        }
        catch(e) {
            console.log('Error!!!', e);
        }

        //2) исправить код чтобы консоль логи показывали от 0 до 10, и написать почему сейчас выводит десять десяток!!
        for (var i = 0; i < 10; i++) {
        	(function(i) {
                setTimeout(function(){
                  console.log(i);
                }, 0);
            })(i);
        }
        // setTimeout попадает в очередь событий event queue. Ноль в конце говорит о том, что функция setTimeout выполнется после текущего кода, в данном случае в Call Stack выполнился весь цикл, а потом уже setTimeout. И, как я понимаю , на момент вызова i уже будет равна 10

        console.log('3е задание:');
        // 3) Есть код!! В какой последовательности выполнится!
        function getDatas() {
            return [
                {
                    name: "Vasia"
                },
                {
                    name: "Boria"
                },
                {
                    name: "Misha"
                },
            ]
        }
        const res = getDatas();
        console.log('RES', res); //выведется 1м (так как код синхронный)
        setTimeout(() => console.log('settimeout1'), 100); // попадает в обработку и выведется последним. Исходя из очереди event queue
        setTimeout(() => console.log('settimeout'), 10); // попадает в обработку и согластно очереди событий event queue выведется 4м (если брать код только в этом примере) когда Call Stack будет чистым.
        console.log('One'); //выполнится 2м (так как код синхронный)
        console.log('two'); //выполнится 3м (так как код синхронный)
        

        //4) Что выведет alert в setTimeOut
        setTimeout(function () {
            alert(j);
        }, 100);

        for (var j = 0; j < 1000000; j++) {
        }
        // alert выводит 1000000 так как функция setTimeout выводится после текущего кода (цикла). И в отличии от примера выше, выведет число один раз, так как находится вне цикла

        // 5) Есть функция funct! Сделать из нее функцию конструктор которая создает обьект со свойствами name lastName
        function funct(name, lastName) {
            // ваш код
            this.name = name;
            this.lastName = lastName;
        }

        let user = new funct('Kate', 'Petrushenko'); 
        console.log(user);


        // 6) Создать функцию конструктор, которая принимает обьект и берет только lastName и position и создает обьект с этих свойств
        function factory(obj) {
            let newObj = {
                lastName: obj.lastName,
                position: obj.position,
            }
            return {
                ...newObj,
                name: 'ZINA'
            };
        }

        let myFactory = new factory({ name: 'Sergei', lastName: 'Shakhov', height: 188, position: 'Software developer' });
        console.log(myFactory);

        // 7)  Создать функцию конструктор, которая принимает два свойства name, lastName конкатенирует их и сохраняет в замыкании в переменной fullName
        // random свойства не будет в обьекте ОБРАТИТЕ ВНИМАНИЕ потому что есть return!! Если не было бы return то был бы обьект с одним свойством
        function factory1(name, lastName) {
            this.name = name;
            this.lastName = lastName;
            var fullName = name + ' ' + lastName;

            this.random = Math.random(); 

            return {
                name: 'ZINA Borisova',
                getRealName: function() {
                    return fullName;
                }
            };
        }
        let name = "Kate";
        let lastName2 = "Petrushenko";
        let q = new factory1(name, lastName2);

        console.log(q);
        console.log(q.getRealName());

        // 8) Есть код! Почему строчка с комментарием покажет {misha: NADUSHA}! Сделать так чтобы a.getObject(); вернул {misha: 'misha'}
        // то есть должны быть независимые обьекты!!
        function newFactory(obj) {
            var object = obj;

            return {
                getObject: function() {
                    return object;
                }
            };
        }
        var a1 = newFactory({misha: 'misha'});
        var k = a1.getObject();
        
        
        k.misha = 'NADUSHA'; 
        a1.getObject(); // КОММЕНТАРИЙ!!! покажет NADUSHA 
        console.log(a1.getObject());
       
        // Почему строчка с комментарием покажет {misha: NADUSHA}
        // - потому что a1 возвращает обьект , а обьект ссылочный тип данных;

        var myNewA1 = new newFactory({misha: 'misha'});
        console.log(myNewA1.getObject()); 

    </script>
</body>

</html>